/**
 * React Starter Kit (https://www.reactstarterkit.com/)
 *
 * Copyright Â© 2014-present Kriasoft, LLC. All rights reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.txt file in the root directory of this source tree.
 */

import React, { PropTypes } from 'react';
import hoistStatics from 'hoist-non-react-statics';

/**
 * Insert StyleSheet object generated by `inline-css-loader` into DOM
 */
let cache;
function insertCss({ id, cssText }, update) {
  if (!cache) {
    cache = {};
    [...document.head.getElementsByTagName('style')].forEach((elem) => {
      const dataId = elem.getAttribute('data-id');
      if (dataId) {
        cache[dataId] = { count: 0, elem, cssText: elem.textContent };
      }
    });
  }

  let inserted = cache[id];
  if (!inserted) {
    inserted = { count: 0, elem: null, cssText };
    cache[id] = inserted;
  }

  if (!inserted.elem) {
    const elem = document.createElement('style');
    inserted.elem = elem;
    elem.setAttribute('data-id', id);
    elem.textContent = cssText;
    document.head.appendChild(elem);
  } else if (inserted.cssText !== cssText) {
    inserted.cssText = cssText;
    inserted.elem.textContent = cssText;
  }

  if (!update) {
    inserted.count += 1;
  }

  // Prevent flash of unstyled content (FOUC)
  return () => window.setTimeout(() => {
    inserted.count -= 1;
    if (inserted.count <= 0 && inserted.elem) {
      inserted.elem.parentNode.removeChild(inserted.elem);
      inserted.elem = null;
    }
  }, 0);
}

function withStyles(...styles) {
  return (WrappedComponent) => {
    class WithStyles extends React.Component {
      static displayName = `WithStyles(${WrappedComponent.displayName || WrappedComponent.name || 'Component'})`;
      static ComposedComponent = WrappedComponent;
      static contextTypes = {
        insertCss: PropTypes.func,
      };

      componentWillMount() {
        if (this.context.insertCss) {
          this.inserted = [];
          styles.forEach(s => this.context.insertCss(s));
        } else {
          this.inserted = styles.map(s => insertCss(s.getCss()));
        }
      }

      componentWillUnmount() {
        this.inserted.forEach(remove => remove());
      }

      render() {
        return <WrappedComponent {...this.props} />;
      }
    }

    // Enable Hot Module Replacement (HMR)
    if (module.hot) {
      WithStyles.prototype.componentWillReceiveProps = function componentWillReceiveProps() {
        if (module.hot.status() === 'apply') {
          this.inserted = styles.map(s => insertCss(s.getCss(), true));
        }
      };
    }

    return hoistStatics(WithStyles, WrappedComponent);
  };
}

export default withStyles;
